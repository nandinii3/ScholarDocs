#!/usr/bin/env python3
import argparse
import os
import io
import re
import hashlib
from typing import List, Optional
import pandas as pd
import requests
from fpdf import FPDF

HERE = os.path.dirname(os.path.abspath(__file__))
OUTPUT_DIR = os.path.join(HERE, "output_pdfs")
CACHE_DIR = os.path.join(HERE, "cache_images")

os.makedirs(OUTPUT_DIR, exist_ok=True)
os.makedirs(CACHE_DIR, exist_ok=True)

def load_data(csv_path: str) -> pd.DataFrame:
    if not os.path.exists(csv_path):
        raise FileNotFoundError(f"CSV not found: {csv_path}")
    df = pd.read_csv(csv_path, dtype=str).fillna("")
    # Normalize common column names to avoid case mismatches
    df.columns = [c.strip() for c in df.columns]
    return df

def filter_by_ids(df: pd.DataFrame, ids: List[str], id_col: str) -> pd.DataFrame:
    if id_col not in df.columns:
        raise KeyError(f"ID column '{id_col}' not found. Available: {list(df.columns)}")
    ids_set = set(str(x).strip() for x in ids)
    return df[df[id_col].astype(str).str.strip().isin(ids_set)]

def _safe_filename(name: str) -> str:
    name = re.sub(r"[^a-zA-Z0-9_.-]+", "_", name).strip("_")
    return name[:128] or "file"

def _download_image(url: str) -> Optional[str]:
    """Download image to cache and return local path. Returns None on failure."""
    if not url or not isinstance(url, str):
        return None
    url = url.strip()
    # Make a stable cache key
    key = hashlib.sha256(url.encode("utf-8")).hexdigest()[:16]
    ext = ".jpg"
    if ".png" in url.lower():
        ext = ".png"
    local_path = os.path.join(CACHE_DIR, f"{key}{ext}")
    if os.path.exists(local_path):
        return local_path
    try:
        resp = requests.get(url, timeout=15)
        resp.raise_for_status()
        with open(local_path, "wb") as f:
            f.write(resp.content)
        return local_path
    except Exception as e:
        print(f"[warn] Could not download image: {e}")
        return None

def generate_pdf(row: pd.Series, mapping: dict, out_dir: str = OUTPUT_DIR) -> str:
    """
    mapping: dict with keys:
      id_col, name_col, class_col, addr_col, photo_col
    """
    sid = row.get(mapping["id_col"], "NA")
    name = row.get(mapping["name_col"], "NA")
    sclass = row.get(mapping["class_col"], "NA")
    addr = row.get(mapping["addr_col"], "NA")
    photo_path = row.get(mapping["photo_col"], "")

    if photo_path and not os.path.exists(photo_path):
        print(f"[WARN] Photo not found for Student ID {sid}: {photo_path}")
        photo_path = None

    pdf = FPDF(orientation="P", unit="mm", format="A4")
    pdf.add_page()
    pdf.set_auto_page_break(auto=True, margin=15)

    # Header
    pdf.set_font("Helvetica", "B", 18)
    pdf.cell(0, 12, "Student Profile", ln=1, align="C")
    pdf.ln(10)

    # If photo exists, place it on the right
    if photo_path and os.path.exists(photo_path):
        try:
            x = 150
            y = 35
            w = 40
            h = 40 
            pdf.image(photo_path, x=x, y=y, w=w)
        except Exception as e:
            print(f"[warn] Could not place image: {e}")
    else:
       print(f"[WARN] Photo not found for Student ID {sid}: {photo_path}")
    # Body
    pdf.set_font("Helvetica", "", 12)
    label_width = 40   # fixed width for labels
    value_width = 80   # fixed width for values (stays before the photo area)
    
    def add_row(label, value):
        pdf.set_font("Helvetica", "B", 12)
        pdf.cell(label_width, 10, f"{label}:", border=0, align="L")
        pdf.set_font("Helvetica", "", 12)
        pdf.cell(value_width, 10, str(value), border=0, align="L", ln=1)
    # Add rows
    add_row("Student ID", sid)
    add_row("Name", name)
    add_row("Class", sclass)
    add_row("Address", addr)

    # --- Footer ---
    pdf.set_y(-20)
    pdf.set_font("Helvetica", "I", 10)
    pdf.cell(0, 10, "Generated by Student PDF Generator", align="C")

    # --- Save PDF ---
    filename = _safe_filename(f"{sid}_{name}.pdf")
    out_path = os.path.join(out_dir, filename)
    pdf.output(out_path)
    return out_path

def main():
    parser = argparse.ArgumentParser(description="Selective Student PDF Generator")
    parser.add_argument("--csv", required=True, help="Path to CSV exported from Google Sheets")
    parser.add_argument("--ids", required=True, help="Comma-separated list of Student_ID values to export")
    parser.add_argument("--id-col", default="Student_ID", help="Column name for the student ID")
    parser.add_argument("--name-col", default="Name", help="Column name for the name")
    parser.add_argument("--class-col", default="Class", help="Column name for the class")
    parser.add_argument("--addr-col", default="Address", help="Column name for the address")
    parser.add_argument("--photo-col", default="Photo", help="Column name for the photo URL")
    args = parser.parse_args()

    df = load_data(args.csv)
    ids = [x.strip() for x in args.ids.split(",") if x.strip()]

    filtered = filter_by_ids(df, ids, args.id_col)
    if filtered.empty:
        print("No matching students found.")
        return

    mapping = {
        "id_col": args.id_col,
        "name_col": args.name_col,
        "class_col": args.class_col,
        "addr_col": args.addr_col,
        "photo_col": args.photo_col,
    }

    for _, row in filtered.iterrows():
        path = generate_pdf(row, mapping, OUTPUT_DIR)
        print(f"[ok] {path}")

if __name__ == "__main__":
    main()
